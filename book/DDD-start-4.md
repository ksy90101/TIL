# 4장. 리포지터리와 모델구현(JPA 중심)

## JPA를 이용한 리포지터리 구현

- 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM 만한게 없다.
- 자바의 표준 ORM인 JPA를 이용해 리포지터리와 애그리거트를 구현하는 방법에 대해 살펴본다.

### 모듈 위치

- 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

![image](https://user-images.githubusercontent.com/53366407/124349538-826f4700-dc2a-11eb-96b2-fc916f2a3df3.png)

- 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

### 리포지터리 기본 기능 구현

- 기본 기능은 아래와 같다.
    - 아이디로 애그리거트 조회하기
    - 애그리거트 저장하기
- 인터페이스는 애그리거트 루트 기준으로 작성한다.
- 애그리거트를 조회하는 기능의 이름을 지을 때 특별한 규칙은 없지만 널리 사용되는 규칙은 `findBy` 프로피터(프로퍼티 값)의 형식을 사용한다.
- save()는 전달받은 애그리거트를 저장한다.
- JPA는 EntityManager를 이용해서 기능을 구현한다.
- 애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요가 없다. JPA는 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영한다.
- 애그리거트 내부의 객체가 변경되면 JPA는 변경 데이터를 DB에 반영하기 위해 UPDATE 쿼리를 실행한다.
- 아이디 외에 다른 조건으로 애그리거트를 조회할 때는 JPA의 Criteria나 JPQL을 사용한다.
- 삭제기능은 delete()를 사용한다.
    - 실제 데이터를 사용하지 않는 경우가 많다. 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터 원복을 위해 일정 기간 동안 보관해야 할 때가 있다. 즉, 소프트 딜리트를 통해 삭제 플레그를 사용하는 경우가 있다.

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

- 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정한다.
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면,
    - 밸류는 `@Embeddable`로 매핑 설정한다.
    - 밸류 타입 프로퍼티는 `@Embeddable`로 매핑 설정한다.

### 기본 생성자

- 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달 받는다.
- 불변 타입이면 생성 시점에 필요한 값을 모두 전달받으므로 값을 변경하는 set 메서드를 제공하지 않는데, 기본 생성자를 추가할 필요가 없다는 것을 뜻하는 것이다.
- 하지만, `@Entity` 와 `@Embeddable` 로 클래스를 매핑하려면 기본 생성자가 필요하다.
- 최대한 다른 코드에서 사용하지 않도록 `protected` 로 선언하면 된다.
    - 하이버네이트는 클래스를 상속한 프록시 객체를 이용해 지연 로딩을 구현한다. 프록시 클래스에서 상위 클래스의 기본 생성자를 호출할 수 있어야 한다. 지연 로딩 대싱이 되는 엔티티의 기본 생성자는 `private` 이 아닌 `protected` 로 되어야 한다.

### 필드 접근 방식 사용

- 메시드 방식을 사용하려면 프로퍼티를 위한 get/set 메서드를 구현하면 된다.
- 그러나 위의 방식은 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높고 캡슐화를 깨트릴 가능성이 높다.
- 따라서 set이 아닌 의미가 있는 메서드명을 사용하는 것이 좋다.
- JPA 구현체인 하이버네이트는 `@Access` 를 이용해서 명시적으로 접근 방식을 지정하지 않으면 `@Id` 나 `@EmbeddedId` 가 어디에 위치했으냐에 따라 접근 방식을 결정한다.

### AttributeConverter를 이용한 밸류 매핑 처리

- int, long, String, LocalDate와 같은 타입은 DB 테이블의 한 개 컬럼과 매핑된다. 그러나 밸류 타입의 프로퍼티를 한 개 컬럼에 매핑해야할 때가 있다.
- JPA2.0에서는 get/set 메서드에서 실제 밸류 타입과 변환 처리를 해야 한다.
- JPA2.1에서는 AttributeConverter를 이용해 가능한다.

### 밸류 컬렉션: 별도 테이블 매핑

- 밸류 컬렉션을 별도 테이블로 매핑할 때는 `@ElementCollection` 과 `@CollectionTable` 을 함께 사용한다.
- `@OrderColumn` 을 이용해서 지정한 컬럼에 리스트의 인덱스 값을 저장한다.
- ``@CollectionTable`은 밸류를 저장할 테이블을 지정할 때 사용한다. name 속성으로 테이블 이름을 지정하고 joinColumns 속성은 외부키로 사용하는 컬럼을 지정한다. 두개 이상인 경우에는 `@JoinColumns` 를 사용하면 된다.

### 밸류 컬렉션: 한 개 컬럼 매핑

- 밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야 할 때가 있는데, AttribteConverter를 사용하면 밸류 컬렉션을 한 개 컬럼에 쉽게 매핑할 수 있다.

### 밸류를 이용한 아이디 매핑

- 식별자는 최종적으로 문자열이나 숫자와 같은 기본 타입이다.
- 그러나 식별자라는 의미를 부각시키기 위해 밸류 타입으로 만들 수 있고 `@EmbeddedId` 를 사용하면 된다ㅣ.
- 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용될 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.
- JPA는 내부적으로 엔티티를 비교할 목적으로 equals() 메서드와 hashcode()를 값을 사용하므로 식별자로 사용할 밸류 타입은 이 두 메서드를 알맞게 구현해야 한다.

### 별도 테이블에 저장하는 밸류 매핑

- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.
- 밸류가 아니라 엔티티가 확실하다면 다른 애그리거트는 아닌지 확인해야 한다. 특히, 자신만의 독자적인 라이프사이클을 갖는다면 다른 애그리거트일 가능성이 높다.
- 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 여부를 확인하는 것이다. 하지만, 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안된다.
- 따라서 `@Embeddable` 과 `@SecondaryTable` 과 `@AttributeOverride` 를 사용하면 된다.

### 밸류 컬렉션을 @Entity로 매핑하기

- 개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 `@Entity` 를 사용해야 할때가 있다.
- JPA는 `@Embeddable` 타입의 클래스 상속 매핑을 지원하지 않는다. 따라서 상속 구조를 갖는 밸류 타입을 사용하려면 `@Entity` 를 이용한 상속 매핑으로 처리해야 한다. 따라서 식별 컬럼을 추가해야 한다.
- `@Inheritance` 를 적용하고 strategy 값으로 `SINGLE_TABLE` 을 사용하고 `@DiscriminatorColumn` 을 이용해서 타입을 구분하는 용도로 사용할 컬럼을 지정한다.
- 아울러 독자적인 라이프사이클을 갖지 않게 하기 위해 cascade 속성을 이용해야 한다.

### ID 참조와 조인 테이블을 이용한 단방향 M:N 매핑

- 애그리거트 간 집합 연관은 성능상의 이유로 피해야 한다고 했다. 그럼에도 불구하고 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있다.
- ID 참조를 이용한 애그리거트 간 단방향 M:N 연관은 밸류 컬렉션 매핑과 동일한 방식으로 설정한 것을 알 수 있다. 차이점이 있다면, 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다는 점이다.
- `@ElementCollection` 을 이용하기 때문에 삭제할 때 매핑에 사용한 조인 테이블의 데이터도 함께 삭제한다. 애그리거트를 직접 참조하는 방식을 사용했다면 영속성 전파나 로딩 전략을 고민해야 하는데 ID 참조 방식을 사용함으로써 이런 고민을 할 필요가 없다.

## 애그리거트 로딩 전략

- JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다. 즉, 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 함을 의미한다.
- 조회 시점에서 상태가 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 하면 된다.
- 그러나 카타시안 조인을 사용하게 되는데, 이는 쿼리 결과에 중복을 발생시킨다. 따라서 조회 성능이 나빠지게 된다.
- 애그리거트는 개념적으로 하나여야 한다. 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.
- 완전해야 하는 이유를 한번 고민해보자.
    - 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 한다.
    - 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하다.
- 따라서 지연로딩을 사용하는 것이 좋다.

## 애그리거트의 영속성 전파

- 저장 메서드는 애그리거트 루트만 저장하면 안 되고 애그리거트에 속한 모든 객체를 저장해야 한다.
- 삭제 메서드는 애그리거트 루트뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.

## 식별자 생성 기능

- 식별자는 크게 세 가지 방식 중 하나로 생성한다.
    - 사용자가 직접 생성
    - 도메인 로직으로 생성
    - DB를 이용한 일련번호 사용
