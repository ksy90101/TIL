# 5장. 리포지터리의 조회 기능(JPA 중심)

## 검색을 위한 스펙

- 리포지터리는 애그리거트의 저장소로 애그리거트를 저장하고 찾고 삭제하는 것이 기본 기능
- 애그리거트를 찾을 때 식별자로 찾지만, 특정 조건을 사용해야 할 게 있다.
- 다양한 조건을 이용해 문제를 풀어야 한다. 이걸 스펙이라고 하고 애그리거트가 특정 조건을 충족하는지 여부를 검사하는 것이다.
- 특정 조건을 충족하는 애그리거트를 찾으려면 이제 원하는 스펙을 생성해서 리포지터리에 전달해 주기만 하면 된다.

### 스펙 조합

- 스펙의 장점은 조합에 있다. AND 또는 OR 연산자를 조합해 새로운 스펙을 만들수도 있고 조합한 스펙을 다시 조합해 더 복잡한 스펙을 만들수도 있다.

## JPA를 위한 스펙 구현

- 스펙을 구현할때, 모든 애그리거트를 조회한 다음 스펙을 이용해 걸러내는 방식을 사용하면 실행속도에 문제가 있다.
- 실제 구현을 할때는 쿼리의 `where` 절에 조건을 붙여서 필요한 데이터를 걸러야 한다.
- JPA는 다양한 검색 조건을 조합하기 위해 `Criteria Builder` 와 `Predicate` 를 사용한다.

### JPA 정적 메타 모델

- `@StaticMetamodel` 을 사용해 관련 모델을 지정한다. 메타 모델 클래스는 이름뒤에 `_` 를 붙힌다.
- 대상 모델의 각 프로퍼티와 동일한 이름을 갖는 정적 필드를 정의한다.

## 정렬 구현

- JPA의 CriteriaQuery#orderBy()를 이용해서 정렬 순서를 지정한다.
- JPA의 Order는 CriteriaBuilder를 이용해야 생성할 수 있다. 정렬 순서를 지정하는 코드는 리포지터리를 사용하는 응용 서비스에 위치하게 되는데 응용 성비스는 CriteriaBuilder에 접근할 수 없다. 응용 성비스는 JPA Order가 아닌 다른 타입을 이용해서 리포지터리에 정렬 순서를 전달하고 JPA 리포지터리는 이를 다시 JPA Order로 변환하는 작업을 해야한다.
- 따라서 문자열로 정렬 순서를 지정하는 것이 좋다.

## 페이징과 개수 구하기 구현

- JPA 쿼리는 setFirstResult()와 setMaxResults()를 제공하는데 두 메서드를 이용해 페이징을 구현할 수 있다.

## 조회 전용 기능 구현

- 다음 용도로 리포지터리를 사용하는 것은 적합하지 않다.
    - 여러 애그리거트를 조합해서 한 화면에 보여주는 데이터 제공
        - 지연 로딩, 즉시 로딩 설정 / 연관 매핑이 문제
    - 각종 통계 데이터 제공
- 위와 같은 기능은 조회 전용 쿼리로 처리해야 한다.

### 동적 인스턴스 생성

- 조회 전용 모델을 만드는 이유는 표현 영역을 통해 사용자에게 데이터를 보여주기 위함이다.
- 동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연/즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있다.

### 하이버네이트 @Subselect 사용

- @Subselect는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능이다.
- `@Subselect` , `@Immutable` , `@Synchronize` 는 하비어네이트 전용 애노테이션인데 이 태그를 사용하려면 테이블이 아닌 쿼리 결과를 @Entity로 매핑할 수 있다.
- `@Subselect` 를 이용한 @Entity의 매핑 필드를 수정하면 하이버네이트는 변경내역을 반영하는 update 쿼리를 실행할 것이다. 그런데, 매핑한 테이블이 없으므로 에러가 발생한다. 이러한 문제를 방지하기 위해 @Imuutable을 사용한다. 사용하면 하이버네이트는 해당 엔티티의 매핑 필드/프로퍼티가 변경되어도 DB에 반영하지 않고 무시한다.
- `@Synchronize` 는 해당 엔티티와 관련된 테이블 목록을 명시한다.
