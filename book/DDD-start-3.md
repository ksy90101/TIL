# 3장. 애그리거트

## 애그리거트

### 상위 수준 개념에서의 이해

- 상위 수준 개념으로 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다. 그러나 상위 모델 이해 없이 상위 수준에서 전체 개념을 이해파악하기에는 오랜시간이 걸린다.

### 하위 수준 개념에서의 이해

- 하위 수준에서 개념을 이해 하기 위해 백 개 이상의 테이블을 한 장의 ERD에 표현하면, 개별 테이블 간의 관계를 파악하느라 큰 틀의 데이터 구조를 이해하는 데 어려움을 겪게 된다. 또한 복잡해지면 구성 요소 위주로 모델을 이해하게 되면서 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기가 어려워진다.

### 그렇다면 어떻게 되는가?

- 관계를 파악하기 어려우면 곧 코드를 변경하고 확장하는 것이 어려워 진다.

### 그럼 해결 방법은?

- 바로 어그리거트를 이용하는 것이다. 관리하고 쉬운 단위로 만들어 상위 수준에서 모델을 볼 수 있는 방법을 사용하는 것이다.

### 애그리거트로 하면 좋은 점은?

- 복잡한 도메인을 이해할 수 있다.
- 일관성을 관리하는 기준이 된다.

### 애그리거트의 특징은?

- 관련된 모델을 하나로 묶은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갇는다. 즉, 구성요소는 대부분 함게 생성하고 함께 제거한다.
    - cf) 무조건은 아니다. 그러나 최대한 이렇게 만드는 것이 중요하다.
- 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 즉, 독립된 객체군이다.

### 애그리거트의 경계

- 경계를 설정을 하는 것이 중요한데, 기본이 되는 것이 바로 도메인 규칙과 요구사항이다.
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다는 것이다.
- 그러나 흔히 'A가 B를 갖는다'라는 요구사항이 있다고 했을때 A와 B는 한 애그리거트로 묶어서 생각하기 쉽지만, 반드시 그래야 할 필요는 없다.
- 처음에 애그리거트로 보이는 것이 많겠지만, 실제 애그리거트의 크기는 점점 줄어들게 된다.

 

## 애그리거트 루트

- 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티다.
- 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티로 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.

### 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애기르거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
- 애그리거트 루트가 아닌 다른 객체가 채그리거트에 속한 객체를 직접 변경하면 안된다. 이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다. 이는 업무 규칙을 무시하고 DB 테이블에서 직접 데이터를 수정하는 것과 같은 결과를 만든다. 즉, 논리적인 일관성이 깨지게 되는 것이다.
- 일관성을 지키기 위해 상태 확인 로직을 응용 서비스에 구현할 수도 있지만, 동일한 검사 로직을 여러 응용 서비스에 중복으로 구현할 가능성이 높아 상황을 더 악화시키기도 한다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 다음의 두 가지를 습관적으로 적용해야 한다.
    - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 밸류 타입은 불변으로 구현한다.

### 공개 set 메서드

- public set 메서드는 필드에 값을 할당하는 것으로 끝이난다. 잘해야 null 검사를 하는 정도이다.
- 가장 큰 단점은 도메인의 의미나 의도를 표현하지 못하고 도메인 로직이 메인 객체가 아닌 응용 영역이나 표현 영역으로 분산되게 만드는 원인이 된다.
- 도메인 로직이 한 곳에 응집되어 있지 않게 되므로 코드를 유지보수할 때에도 분석하고 수정하는 데 많은 시간을 들이게 된다.
- 따라서 의미가 더 잘 들어나는 이름을 사용하자.

### Value의 불변 타입

- 값을 변경할 수 없으면 애그리거트 루트에서 Value 객체를 구해도 값을 변경할 수 없기 때문에 애그리거트 외부에서 Value 객체의 상태를 변경할 수 없게 된다.
- 즉, 애그리거트 루트가 제공하는 메서드에 새로운 Value 객체를 전달해서 값을 변경하는 방법만 사용해야 한다.

### 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성해야 한다.
- 변경 기능을 패키지나 protected 범위로 한정해서 외부에 실행할 수 없도록 제한해야 한다.

### 트랜잭션 범위

- 트랜잭션 범위는 작을 수록 좋다. 잠금 대상이 많을 수록 성능을 떨어트린다.
- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가성이 높아지기 때문에 전체 성능이 떨어진다.
- 위의 말은 한 트랜잭션에서 하나의 애그리거트만 수정하고 다른 애그리거트는 변경하지 않는다는 의미이다.
- 두 개의 애그리거트를 한 트랜잭션에서 변경하면 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하게 되는 것이다. 가장 중요한건 애그리거트간의 독립성인데 한 애그리거트에 의존하면 애그리거트 간의 결합도가 늘어나게 되면서 향후 수정 비용이 늘어난다.
- 만약 한 트랜잭션에서 두 개의 애그리거트를 수정해야 한다면, 한 애그리거트에서 직접 수정하지 않고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.
- 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서 동기나 비동기로 다른 애그리거트 상태를 변경하는 코드 작성이 가능하다.

### 한 개의 트랜잭션에서 두 개이상의 애그리거트를 수정해야 하는 경우

- 팀 표준
    - 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우
    - DB가 다른 경우 글로벌 트랜잭션을 반드시 사용하도록 규칙을 정한 곳
- 기술 제약
    - 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
- UI 구현의 편리
    - 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 헌 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경할 수 있다.

## 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 새로운 애그리거트를 만들면 저장소에 애그리거트를 영속화하고 애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 하므로 리포지터리는 적어도 다음의 두 메서드를 제공해야 한다.
    - save : 애그리거트 저장
    - findById: ID로 애그리거트를 구함
- 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NPE가 발생할 수 있다.
- 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다. 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.

## ID를 이용한 애그리거트 참조

### 필드를 이용한 애그리거트 참조의 문제

1. 편한 탐색 오용
    - 쉽게 접근이 가능하기 때문에 상태를 쉽게 변경할 수 있다. 트랜잭션 범위에서 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 하는데, 내부에서 다른 애그리거트 객체에 접근할 수 있기 때문에 위험하다.
2. 성능에 대한 고민
    - 예를들어 지연로딩, 즉시 로딩 두 방법에 따라 성능이 달라진다. 또한 다양한 경우의 수를 고려해 연관 매핑과 JPQL/Criteria 쿼리의 로딩 전략으로 결정해야 한다.
3. 확장 어려움
    - DB가 확장되버리면 도메인을 분리하기;가 어렵다.

### 그럼 어떻게?

- 위와 같은 문제를 해결하기 위해 ID 참조를 하면 좋다.
- 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결되면서 구현 복잡도가 낮아진다.

### ID를 잉요한 참조와 조회 성능

- 그러나 조회 속도가 문제가 있다.
- 바로 N+1문제인데, 이걸 해결하기 위해 JOIN을 사용하면 된다.
- 바로 전용 조회 쿼리로 데이터 조회를 위한 별도 DAO를 만들고 DAO의 조회 메서드에서 세타 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩하면 된다.

## 애그리거트 간 집합 연관

### 1:N

```jsx
public class Category {
	private Set<Product> products;
}
```

- 그러나 개념적으로 존재하는 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과 상관없는 경우가 종종 있다.
- 개념적으로는 애그리거트 간에 1:N 연관이 있더라도 이런 성능상의 문제 때문에 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 경우는 드물다.

### N:M

```jsx
@Entity
@Table(name = "product")
public class Product {
	@EmbeddedId
	private ProductId id;

	@ElementCollection
	@CollectionTable(name = "product_category",
							joinColumns = @JoinColumn(name = "product_id"))
	private Set<CategoryId> categoryIds;
}
```

- N:M은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다. 그러나 개념적으로는 상품과 카테고리의 양방향 M:N 연관이 존재하지 않지만 실제 구현에서는 상품에서 카테고리로 단방향 M:N 연관만 적용하면 된다.
- 이때 사용하는 것은 조인 테이블이다.

## 애그리거트를 팩토리로 사용하기

- 애그리거트가 갖고 있는 데이터를 이용해 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
